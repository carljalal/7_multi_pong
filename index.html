<html>
<body>
<script>
// abstract game editor (idea for later)
// onButton (idea for later)
// storyEngine (idea for later)
// address game -- references to references, spatial find -- zoomin tree -- grid? (idea for later)
// range-matcher (genetic algorithm)




/// put div for instructions
instructionsDiv = document.createElement("div");
document.body.append(instructionsDiv);
instructionsDiv.innerHTML = "Welcome to Multi Pong!";



/// start button
startButton = document.createElement("button");
document.body.append(startButton);
startButton.innerText = "Start!";



/// stop button
stopButton = document.createElement("button");
document.body.append(stopButton);
stopButton.innerText = "Stop!";



/// put all options settings (radios, slider, textboxes, buttons)
defaultBallSpeed    = 1;
defaultUpdateSpeed  = 10;
defaultCanvasHeight = "500px";
defaultCanvasWidth  = "500px";
defaultCanvasBorder = "2px solid grey"
paddleSelected = null;



/// put canvas
canvasElement = document.createElement("canvas");
document.body.append(canvasElement);
canvasElement.style.width = defaultCanvasWidth;
canvasElement.style.height= defaultCanvasHeight;
canvasElement.style.border= defaultCanvasBorder;
canvasElement.width = 500;
canvasElement.height = 500;
ctx = canvasElement.getContext("2d");


/// put global variables
balls    = [{name:"first",x:100,y:100},{name:"second",x:200,y:200},{name:"third",x:300,y:300}]
walls    = [{name:"left",x:10,y:250,w:5,h:250},{name:"right",x:490,y:250,w:5,h:250},{name:"bottom",x:250,y:10,w:250,h:5},{name:"top",x:250,y:490,w:250,h:5},{name:"middle",x:250, y:300,w:5,h:60}]
paddles  = [{name:"first",x:100,y:30,h:10,w:20},{name:"second",x:200,y:30,h:10,w:20},{name:"third",x:300,y:30,h:10,w:20}]
oobAreas = [{name:"left",x:-50,y:250,w:50,h:500},{name:"right",x:550,y:250,w:50,h:500},{name:"bottom",x:250,y:-50,w:500,h:50},{name:"top",x:250,y:550,w:500,h:50}]




/// set bounding box
refreshBoundingBox = (object) => {
    object.minX = object.x - object.w;
    object.maxX = object.x + object.w;

    object.minY = object.y - object.h;
    object.maxY = object.y + object.h;
}




// initialization loops
initializeAll = () => {
    // initialize colors to black
    balls.forEach(ball => {
        ball.color = "black";
        ball.w = 5;
        ball.h = 5;
        refreshBoundingBox(ball);
    });
    walls.forEach(wall => {
        wall.color = "black";
        refreshBoundingBox(wall);
        
    });
    paddles.forEach(paddle => {
        paddle.color = "black";
        refreshBoundingBox(paddle);
        
    });
}
initializeAll();





/// put timerloop
mainLoop = () => {
    moveUpdate();
    collisionUpdate();
    drawUpdate();
}
setInterval(mainLoop, defaultUpdateSpeed);


/// intersects bounding box
pointIntersectsBox = (x, y, box) => {
    if (x >= box.minX && x <= box.maxX && y >= box.minY && y <= box.maxY) {
        return true;
    }
    else return false;
}

boxIntersectsBox = (box1, box2) => {
    if (box1.maxX < box2.minX || box1.minX > box2.maxX || box1.maxY < box2.minY || box1.minY > box2.maxY) {
        return false;
    }
    else return true;
}



/// paddle intersect
cursorPaddleIntersect = (cursorX,cursorY) => {
    // loop check bounding box
    paddles.forEach(paddle, index => {
        // check cursor in bounding box
        if (pointIntersectsBox(paddle,cursorX,cursorY)){
            paddleSelected = index;
        }
    });
}




/// move direction functions
moveLeft = (object, amount=1) => {
    object.x -= amount;
    refreshBoundingBox(object);
}

moveRight = (object, amount=1) => {
    object.x += amount;
    refreshBoundingBox(object);
}

moveUp = (object, amount=1) => {
    object.y -= amount;
    refreshBoundingBox(object);
}

moveDown = (object, amount=1) => {
    object.x += amount;
    refreshBoundingBox(object);
}

moveIt = (object) => {
    if (object.dirX == "left")  moveLeft(object);
    if (object.dirX == "right") moveRight(object);
    if (object.dirY == "up")    moveUp(object);
    if (object.dirY == "down")  moveDown(object);
}



// destination check
atDestination = (object) => {
    return (object.x == object.destX && object.y == object.destY)
}

fixDirection = (object) => {
    if (atDestination(object)) {
        object.dirX == null;
        object.dirY == null;
    }
}


// general move all iterations
moveUpdate = () => {
    balls.forEach(ball => {
        moveIt(ball);
    })
    paddles.forEach(paddle => {
        moveIt(paddle);
        fixDirection(paddle); // if paddle has reached destination, set directions to null
    })
}






/// reverse direction
reverseDirection = (object) => {
    object.dirX = object.dirX == "left" ? "right" : "left";
    object.dirY = object.dirY == "up" ? "down" : "up";
}






/// put collision logic
collisionUpdate = () => {
    // loop balls
    balls.forEach(ball => {
        // inner loop walls
        walls.forEach(wall => {
            if (boxIntersectsBox(ball,wall)){
                // change ball direction
                reverseDirection(ball);
            }
        })

        // inner loop paddles
        paddles.forEach(paddle => {
            if (boxIntersectsBox(ball,paddle)){
                // change ball direction
                reverseDirection(ball);
            }
        })

        // inner loop out of bounds areas
        oobAreas.forEach(area => {

        })
    });
}



/// simple draw
drawRect = (object) => {
    ctx.fillStyle = object.color;
    ctx.fillRect(object.minX, object.minY, object.maxX - object.minX, object.maxY - object.minY);
}




/// put canvas draw calls
drawUpdate = () => {
    // clear canvas
    ctx.clearRect(0,0,canvasElement.width,canvasElement.height);
    
    // draw balls
    balls.forEach(ball => drawRect(ball));
    
    // draw walls
    walls.forEach(wall => drawRect(wall));

    // draw paddles
    paddles.forEach(paddle => drawRect(paddle));

}



/// put click logic -- paddle movement commands
canvasElement.onClick = () => {
    // switch between
    
    // paddle select
    if (paddleSelected == null){
        paddles.forEach(paddle, index =>{
            if(pointIntersectsBox(event.x, event.y, paddle)){
                paddleSelected = index;
            }
        })
    }
    // paddle move -- set direction and destination
    else {
        
    }

}




/// put keypress logic -- paddle movement commands
canvasElement.onkeydown = (event) => {
    if (paddleSelected != null) {
        return;
    }
    else {
        if(event.key == "ArrowLeft"  ) paddle[paddleSelected].moveLeft();
        if(event.key == "ArrowRight" ) paddle[paddleSelected].moveRight();
        if(event.key == "ArrowUp"    ) paddle[paddleSelected].moveUp();
        if(event.key == "ArrowDown"  ) paddle[paddleSelected].moveDown();
        if(event.key == "q"  )         paddleSelected = null;
    }
}



// put settings logic




</script>
</body>
</html>